const storage_client = require("../cloud_storage/storage_client");
const Busboy = require("busboy");
const {PassThrough} = require("stream");
const {userModel} = require("../db/schemas/userSchema");
const uuid = require("uuid");
const {updateQueryOptions} = require("../controllers/userController");
let parseStream;
let parseBuffer;
import("music-metadata").then((music_metadata) => {
  parseStream = music_metadata.parseStream;
  parseBuffer = music_metadata.parseBuffer;
});

const mediaTypeToFieldMap = {
  0: "audioFiles",
  1: "playlists",
};
const uploadAudioFile = async (req, res) => {
  // memory efficient streaming instead of full upload to a buffer
  const {userID} = req;
  // set up function scoped resources for the upload
  const busboy = Busboy({headers: req.headers});
  const bucket = storage_client.bucket(process.env.USER_DATA_BUCKET);
  let busboyFinished = false;
  let fileCounter = 0;
  const {playlistID} = req.params;

  busboy.on("file", (fieldname, file, {filename, encoding, mimeType}) => {
    fileCounter++;
    // dummy file just to get the _id generated by mongoose and use it to save to storage
    // filename is required by the schema
    const newID = uuid.v4();
    const newFile = bucket.file(`${userID}/${newID}`);
    const metadataStream = new PassThrough();
    // asynchronously parse metadata as the stream is incoming
    const audioFileMetadata = parseAudioFileMetadata(metadataStream, {
      filename,
      encoding,
      mimeType,
      _id: newID,
    });

    console.log(`Uploading files. ${filename} ${mimeType} ${encoding}`);

    const storageWriteStream = newFile.createWriteStream({
      metadata: {
        contentType: mimeType,
      },
      resumable: false,
    });

    file
      .on("data", (chunk) => {
        storageWriteStream.write(chunk);
        metadataStream.write(chunk);
      })
      .on("end", (variable) => {
        storageWriteStream.end();
        metadataStream.end();
      });
    storageWriteStream.on("finish", async () => {
      // only add to database if successfully added to storage
      try {
        // remove processed file from file count.
        console.log("finished");

        const [audioFile] = await Promise.all([audioFileMetadata]);
        if (playlistID) {
          // add to playlist if playlist ID is provided
          await userModel.updateOne(
            {
              _id: userID,
              "playlists._id": playlistID,
            },
            {
              $push: {
                "playlists.$.audioFiles": {...audioFile, playlistID},
              },
            },
            {
              ...updateQueryOptions,
            }
          );
        } else {
          // add to root if playlist ID is not provided
          await userModel.updateOne(
            {_id: userID},
            {
              $push: {
                audioFiles: audioFile,
              },
            },
            updateQueryOptions
          );
        }
        fileCounter--;
        // check that busboay has emitted file events for ALL files
        // and all the files have finished uploading i.e counter === 0.
        if (busboyFinished === true && fileCounter === 0) {
          console.log("uploading last file");
          res.sendStatus(201);
        }
      } catch (err) {
        console.log(err);
      }
    });
    storageWriteStream.on("error", (error) => {
      console.log(error);
      newFile.delete();
    });
  });

  busboy.on("finish", () => {
    // console.log(metadataStream.read());
    busboyFinished = true;
  });
  req.pipe(busboy);
};

/**
 * Takes an incoming audioFile stream and parses its metadata. Writes this data to a new object that follows the AudioFileSchema
 * @param {Stream.Readable} stream - Incoming passthrough stream with the audio file data
 * @param {Object} fileInfo - Object containing information such as filename and mimeType
 * @returns {Object} - Object containing all the metadata in the shape defined in the AudioFile Schema
 * */
const parseAudioFileMetadata = async (stream, fileInfo) => {
  const {filename, mimeType, _id} = fileInfo;
  const newAudioFile = {filename, _id};
  try {
    const metadata = await parseStream(stream, {mimeType});
    const {common, format} = metadata;

    newAudioFile.title = common?.title;
    newAudioFile.album = common?.album;
    newAudioFile.artists = common?.artists;
    newAudioFile.trackNumber = common.track
      ? `${common.track.no}/${common.track.of}`
      : null;
    newAudioFile.icon = common.picture
      ? {
        mimeType: common.picture[0]?.format,
        data: common.picture[0].data.toString("base64"),
      }
      : {
        mimeType: undefined,
        data: undefined,
      };

    newAudioFile.duration = format?.duration;
    newAudioFile.format = {
      container: format.container,
      codec: format.codec,
      mimeType: mimeType,
      sampleRate: format.sampleRate,
      bitrate: format.bitrate,
      channels: format.numberOfChannels,
    };
  } catch (error) {
    console.log(error);
  }

  return newAudioFile;
};

const uploadMedia2 = async (req, res) => {
  // uses multer middleware to add file info to req object
  try {
    console.log("uploading file");
    // Access the uploaded file using req.file.buffer
    const {originalname, buffer, mimetype} = req.file;
    //const uploadMetadata = await music_metadata.parseBuffer(buffer, mimetype)
    const newFile = storage_client
      .bucket(process.env.GOOGLE_CLOUD_TEST_BUCKET)
      .file(originalname);
    await newFile.save(buffer);
    //res.send(uploadMetadata)
  } catch (e) {
    console.log(e);
    res.status(500).send(e);
  }
};

const downloadAudioFile = async (req, res) => {
  // protected route so userID is in res object
  const {userID} = req;
  const buffer = [];
  const {audioFileID} = req.params;
  try {
    const file = storage_client.bucket(process.env.USER_DATA_BUCKET).file(`${userID}/${audioFileID}`);
    const metadata = await file.getMetadata();
    const contentType = metadata[0].contentType;
    res.setHeader("Content-Type", contentType);
    file
      .createReadStream()
      .on("data", (chunk) => {
        buffer.push(chunk);
      })
      .on("error", (e) => {
        res.status(500).send(e);
      })
      .on("end", () => {
        const finalBuffer = Buffer.concat(buffer);
        res.status(200).send(finalBuffer.toString("base64"));
        console.log(`file: ${file.name} has been successfully downloaded`);
      });
    // .on("response", (response) => {}) do no thing on server response
  } catch (err) {
    return res.status(500).send(err);
  }
};

/**
 * Delete an audioFile object from storage. This action is non-reversible.
 * Throws an error on failure
 * @param {String} userID - ID of the user which is typically the name of the bucket containing their files in storage
 * @param {String} filename - name of the file to delete, which is typically the ID of the file
 */
const deleteAudioFileFromStorage = async (userID, filename) => {
  const audioFile = storage_client.bucket(process.env.USER_DATA_BUCKET).file(`${userID}/${filename}`);
  await audioFile.delete();
};

/**
 * Delete audioFile from the database.
 * audioFile can only be of two types:
 * 0 - audioFile in the root.
 * 2 - audioFile in a playlist.
 * Throws error on failure.
 * @param {Number} type - Type of the audioFile (can only be 0 or 2)
 * @param {String} userID - ID of the user document to update
 * @param {String} mediaID - ID of the media to delete
 * @param {String} playlistID - If type === 2, then provide the ID of the playlist the audioFile is in
 */
const deleteAudioFileFromDb = async (type, userID, mediaID, playlistID) => {
  if (type === 0) {
    // delete from root
    return await userModel.updateOne(
      {_id: userID},
      {
        $pull: {
          audioFiles: {
            _id: mediaID,
          },
        },
      },
      {updateQueryOptions}
    );
  } else if (type === 2) {
    // delete from playlist
    return await userModel.updateOne(
      {
        _id: userID,
        playlists: {
          $elemMatch: {
            _id: playlistID,
          },
        },
      },
      {
        $pull: {
          "playlists.$.audioFiles": {
            _id: mediaID,
          },
        },
      },
      updateQueryOptions
    );
  }
};

const deleteAudioFile = async (req, res) => {
  const {userID} = req;
  const {audioFileID, playlistID} = req.params;
  try {
    // delete file from cloud storage
    await deleteAudioFileFromStorage(userID, audioFileID);
  } catch (e) {
    console.log(e);
    return res.status(500).send(e);
  }
  // only after deleting file from storage was successful

  try {
    // query the user and get only the appropriate field
    if (!playlistID) {
      // delete from root
      const result = await deleteAudioFileFromDb(0, userID, audioFileID);
    } else {
      // delete from playlist
      const result = await deleteAudioFileFromDb(
        2,
        userID,
        audioFileID,
        playlistID
      );
    }
    res.sendStatus(200);
  } catch (error) {
    console.log(error);
    res.send(error);
  }
};

const deletePlaylist = async (req, res) => {
  const {userID} = req;
  const {playlistID} = req.params;

  try {
    // get the bucket and make the query to delete items
    const query = await userModel.findOne(
      {
        _id: userID,
        playlists: {
          $elemMatch: {
            _id: playlistID,
          },
        },
      },
      {"playlists.$": 1, _id: 0}
    );
    // get the playlist object to delete from the document
    const playlist = query.playlists[0];
    // delete every song in the playlist from storage then from database
    for (let i = 0; i < playlist.audioFiles.length; i++) {
      let fileToDeleteID = playlist.audioFiles[i]._id;
      await deleteAudioFileFromStorage(userID, fileToDeleteID);
      await deleteAudioFileFromDb(2, userID, fileToDeleteID, playlistID);
    }
    // erase the whole playlist from the user playlists lists
    await userModel.updateOne(
      {
        _id: userID,
      },
      {
        $pull: {
          playlists: {
            _id: playlistID,
          },
        },
      }
    );
    res.sendStatus(200);
  } catch (error) {
    console.log(error);
    res.status(500).send(error);
  }
};

const createPlaylist = async (req, res) => {
  const {userID} = req;
  const {name} = req.body;
  console.log(name);
  try {
    const query = await userModel.updateOne(
      {_id: userID},
      {
        $push: {
          playlists: {
            name,
          },
        },
      },
      updateQueryOptions
    );
    res.sendStatus(201);
  } catch (err) {
    res.send(err);
  }
};
const getMediaInfo = async (req, res) => {
  try {
    const {userID} = req;
    const {mediaType, mediaID} = req.params;
    const mediaField = mediaTypeToFieldMap[mediaType];
    const projectionString = mediaField + ".$";
    // programatically create the query projetion the nested subdocuments in the array
    const mediaFieldProjection = {};
    mediaFieldProjection[projectionString] = 1;

    // programatically create filter for user documents
    const queryFilter = {
      _id: userID,
    };
    queryFilter[mediaField] = {
      $elemMatch: {
        _id: mediaID,
      },
    };
    const query = await userModel.findOne(queryFilter, mediaFieldProjection);
    if (!query) {
      res.sendStatus(404);
    } else {
      res.json(query.playlists[0]);
    }
  } catch (err) {
    console.log(err);
    res.send(err);
  }
};
const __getMediaInfo = async (req, res) => {
  try {
    const {userID} = req;
    const {mediaType, mediaID} = req.params;
    // field in user document. Typically contains an array
    const mediaField = mediaTypeToFieldMap[mediaType];
    // string to query media object in array field
    const mediaQueryString = mediaField + "_id";
    // projection string. Ex: "audioFiles.$"
    const projectionString = mediaField + ".$";

    const mediaObject = await userModel.find(
      {_id: userID, mediaQueryString: mediaID},
      {projectionString: 1}
    );
    res.json(mediaObject);
  } catch (err) {
    res.json(err);
  }
};

const uploadProfilePicture = async (req, res) => {
  const {userID} = req;
  const user = userModel.findById(userID, {profilePicture: 1});
};

const getProfilePicture = async (req, res) => {
};

module.exports = {
  uploadAudioFile,
  downloadAudioFile,
  deleteAudioFile,
  deletePlaylist,
  getMediaInfo,
  createPlaylist,
};
