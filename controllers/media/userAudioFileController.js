const storage_client = require("../../cloud_storage/storage_client");
const Busboy = require("busboy");
const {PassThrough} = require("stream");
const {userModel} = require("../../db/schemas/user/userSchema");
const uuid = require("uuid");
const {updateQueryOptions} = require("../user/userController");
const music_metadata = import("music-metadata")
const uploadAudioFile = async (req, res) => {
  // memory efficient streaming instead of full upload to a buffer
  const {userID} = req;
  // set up function scoped resources for the upload
  const busboy = Busboy({headers: req.headers});
  const bucket = storage_client.bucket(process.env.USER_DATA_BUCKET);
  let busboyFinished = false;
  let fileCounter = 0;
  const {playlistID} = req.params;

  busboy.on("file", (fieldname, file, {filename, encoding, mimeType}) => {
    fileCounter++;
    // dummy file just to get the _id generated by mongoose and use it to save to storage
    // filename is required by the schema
    const newID = uuid.v4();
    const newFile = bucket.file(`${userID}/${newID}`);
    const metadataStream = new PassThrough();
    // asynchronously parse metadata as the stream is incoming
    const audioFileMetadata = parseAudioFileMetadata(metadataStream, {
      filename,
      encoding,
      mimeType,
      _id: newID,
    });

    console.log(`Uploading files. ${filename} ${mimeType} ${encoding}`);

    const storageWriteStream = newFile.createWriteStream({
      metadata: {
        contentType: mimeType,
      },
      resumable: false,
    });

    file
      .on("data", (chunk) => {
        storageWriteStream.write(chunk);
        metadataStream.write(chunk);
      })
      .on("end", (_) => {
        storageWriteStream.end();
        metadataStream.end();
      });
    storageWriteStream.on("finish", async () => {
      // only add to database if successfully added to storage
      try {
        // remove processed file from file count.
        console.log("finished");

        const [audioFile] = await Promise.all([audioFileMetadata]);
        if (playlistID) {
          // add to playlist if playlist ID is provided
          await userModel.updateOne(
            {
              _id: userID,
              "playlists._id": playlistID,
            },
            {
              $push: {
                "playlists.$.audioFiles": {...audioFile, playlistID},
              },
            },
            {
              ...updateQueryOptions,
            }
          );
        } else {
          // add to root if playlist ID is not provided
          await userModel.updateOne(
            {_id: userID},
            {
              $push: {
                audioFiles: audioFile,
              },
            },
            updateQueryOptions
          );
        }
        fileCounter--;
        // check that busboay has emitted file events for ALL files
        // and all the files have finished uploading i.e counter === 0.
        if (busboyFinished === true && fileCounter === 0) {
          console.log("uploading last file");
          res.sendStatus(201);
        }
      } catch (err) {
        console.log(err);
      }
    });
    storageWriteStream.on("error", (error) => {
      console.log(error);
      newFile.delete();
    });
  });

  busboy.on("finish", () => {
    // console.log(metadataStream.read());
    busboyFinished = true;
  });
  req.pipe(busboy);
};

/**
 * Takes an incoming audioFile stream and parses its metadata. Writes this data to a new object that follows the AudioFileSchema
 * @param {Stream.Readable} stream - Incoming passthrough stream with the audio file data
 * @param {Object} fileInfo - Object containing information such as filename and mimeType
 * @returns {Object} - Object containing all the metadata in the shape defined in the AudioFile Schema
 * */
const parseAudioFileMetadata = async (stream, fileInfo) => {
  const {filename, mimeType, _id} = fileInfo;
  const newAudioFile = {filename, _id};
  try {
    const parseStream = (await music_metadata).parseStream
    const metadata = await parseStream(stream, {mimeType});
    const {common, format} = metadata;

    newAudioFile.title = common?.title;
    newAudioFile.album = common?.album;
    newAudioFile.artists = common?.artists;
    newAudioFile.trackNumber = common.track
      ? `${common.track.no}/${common.track.of}`
      : null;
    newAudioFile.icon = common.picture
      ? {
        mimeType: common.picture[0]?.format,
        data: common.picture[0].data.toString("base64"),
      }
      : {
        mimeType: undefined,
        data: undefined,
      };

    newAudioFile.duration = format?.duration;
    newAudioFile.format = {
      container: format.container,
      codec: format.codec,
      mimeType: mimeType,
      sampleRate: format.sampleRate,
      bitrate: format.bitrate,
      channels: format.numberOfChannels,
    };
  } catch (error) {
    console.log(error);
  }

  return newAudioFile;
};

const downloadAudioFile = async (req, res) => {
  // protected route so userID is in res object
  const {userID} = req;
  const buffer = [];
  const {audioFileID} = req.params;
  try {
    const file = storage_client
      .bucket(process.env.USER_DATA_BUCKET)
      .file(`${userID}/${audioFileID}`);
    const metadata = await file.getMetadata();
    const contentType = metadata[0].contentType;
    res.setHeader("Content-Type", contentType);
    file
      .createReadStream()
      .on("data", (chunk) => {
        buffer.push(chunk);
      })
      .on("error", (e) => {
        res.status(500).send(e);
      })
      .on("end", () => {
        const finalBuffer = Buffer.concat(buffer);
        res.status(200).send(finalBuffer.toString("base64"));
        console.log(`file: ${file.name} has been successfully downloaded`);
      });
    // .on("response", (response) => {}) do no thing on server response
  } catch (err) {
    return res.status(500).send(err);
  }
};

/**
 * Delete an audioFile object from storage. This action is non-reversible.
 * Throws an error on failure
 * @param {String} userID - ID of the user which is typically the name of the bucket containing their files in storage
 * @param {String} filename - name of the file to delete, which is typically the ID of the file
 */
const deleteAudioFileFromStorage = async (userID, filename) => {
  const audioFile = storage_client
    .bucket(process.env.USER_DATA_BUCKET)
    .file(`${userID}/${filename}`);
  await audioFile.delete();
};

/**
 * Delete audioFile from the database.
 * audioFile can only be of two types:
 * 0 - audioFile in the root.
 * 2 - audioFile in a playlist.
 * Throws error on failure.
 * @param {Number} type - Type of the audioFile (can only be 0 or 2)
 * @param {String} userID - ID of the user document to update
 * @param {String} mediaID - ID of the media to delete
 * @param {String | undefined} playlistID - If type === 2, then provide the ID of the playlist the audioFile is in
 */
const deleteAudioFileFromDb = async (type, userID, mediaID, playlistID = undefined) => {
  if (type === 0) {
    // delete from root
    return userModel.updateOne(
      {_id: userID},
      {
        $pull: {
          audioFiles: {
            _id: mediaID,
          },
        },
      },
      {updateQueryOptions}
    );
  } else if (type === 2) {
    // delete from playlist
    return userModel.updateOne(
      {
        _id: userID,
        playlists: {
          $elemMatch: {
            _id: playlistID,
          },
        },
      },
      {
        $pull: {
          "playlists.$.audioFiles": {
            _id: mediaID,
          },
        },
      },
      updateQueryOptions
    );
  }
};

const deleteAudioFile = async (req, res) => {
  const {userID} = req;
  const {audioFileID, playlistID} = req.params;
  try {
    // delete file from cloud storage
    await deleteAudioFileFromStorage(userID, audioFileID);
  } catch (e) {
    console.log(e);
    return res.status(500).send(e);
  }
  // only after deleting file from storage was successful

  try {
    // query the user and get only the appropriate field
    if (!playlistID) {
      // delete from root
      const result = await deleteAudioFileFromDb(0, userID, audioFileID);
    } else {
      // delete from playlist
      const result = await deleteAudioFileFromDb(
        2,
        userID,
        audioFileID,
        playlistID
      );
    }
    res.sendStatus(200);
  } catch (error) {
    console.log(error);
    res.send(error);
  }
};

module.exports = {
  uploadAudioFile,
  parseAudioFileMetadata,
  downloadAudioFile,
  deleteAudioFile,
  deleteAudioFileFromDb,
  deleteAudioFileFromStorage,
}